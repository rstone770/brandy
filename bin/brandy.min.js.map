{"version":3,"sources":["brandy.js","container.js","helpers.js","index.js","lifecycle.js","map.js"],"names":["global","Container","map","cache","bind","type","implementation","options","bindingOptions","dependencies","lifecycle","TypeError","constructor","Array","factory","asFactory","slice","call","set","id","uid","Lifecycle","parse","DEFAULT","pending","api","instance","strict","descriptor","get","Error","typeToString","SINGLETON","asSingleton","TRANSIENT","asTransient","result","container","construct","dependency","params","Function","apply","concat","next","prototype","has","Object","hasOwnProperty","brandy","Mapping","version","root","define","amd","exports","module","Brandy","value","name","toUpperCase","NATIVE_MAP_SUPPORTED","keys","values","key","indexOf","index","push","Map","this"],"mappings":"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","file":"brandy.min.js","sourcesContent":["/**!\n * brandy 1.0.0 - A tiny IoC container.\n * http://www.github.com/rstone770/brandy\n *\n * Licensed MIT\n */\n;(function(global) {\n\"use strict\";\n\n/**\n * IoC container.\n *\n * @param {Mapping} map\n */\nvar Container = function (map) {\n\n  /**\n   * Internal cache for singleton instances.\n   *\n   * @type {Object}\n   */\n  var cache = {};\n\n  /**\n   * Binds a implementation to a type.\n   *\n   * @param  {*} type\n   * @param  {Function} implementation\n   * @param  {Object=} options\n   * @return {Container}\n   */\n  var bind = function (type, implementation, options) {\n    var bindingOptions = options || {},\n        dependencies = bindingOptions.dependencies || [],\n        lifecycle = bindingOptions.lifecycle;\n\n    if (typeof implementation !== 'function') {\n      throw new TypeError('Implementation must be a constructor.');\n    }\n\n    if (dependencies.constructor !== Array) {\n      throw new TypeError('Dependencies must be an array.');\n    }\n\n    return factory(type, asFactory(implementation, slice.call(dependencies)), lifecycle);\n  };\n\n  /**\n   * Binds a factory to a type.\n   *\n   * @param  {*} type\n   * @param  {Function(container: Container): *} factory\n   * @param  {Lifecycle} lifecycle\n   * @return {Container}\n   */\n  var factory = function (type, factory, lifecycle) {\n    if (typeof factory !== 'function') {\n      throw new TypeError('Factory must be a function.');\n    }\n\n    if (lifecycle != null && typeof lifecycle !== 'string') {\n      throw new TypeError('Lifecycle must be a string.');\n    }\n\n    map.set(type, {\n      factory: factory,\n      id: uid(),\n      lifecycle: Lifecycle.parse(lifecycle || Lifecycle.DEFAULT),\n      pending: false\n    });\n\n    return api;\n  };\n\n  /**\n   * Returns an instance bound to T. If the strict boolean is set, the return instance\n   * must be a non null or undefined value.\n   *\n   * @throws {Error} If dependency could not be resolved.\n   * @throws {Error} If a circular dependency is detected.\n   * @throws {Error} If an unsupported lifecycle is defined.\n   * @throws {Error} If strict is set, but the return instance did not reutrn a valid instance.\n   *\n   * @param  {*} type\n   * @param  {Boolean=} strict\n   * @return {*}\n   */\n  var instance = function (type, strict) {\n    var descriptor = map.get(type),\n        instance = null;\n\n    if (descriptor == null) {\n      throw new Error('Dependency ' + typeToString(type) + ' could not be resolved because it has not been registered.');\n    }\n\n    var id = descriptor.id,\n        lifecycle = descriptor.lifecycle;\n\n    if (descriptor.pending === true) {\n      throw new Error('Circular dependency detected while resolving ' + typeToString(type, id) + '.');\n    }\n\n    descriptor.pending = true;\n\n    try {\n      switch (lifecycle) {\n        case Lifecycle.SINGLETON:\n          instance = asSingleton(descriptor);\n          break;\n        case Lifecycle.TRANSIENT:\n          instance = asTransient(descriptor);\n          break;\n        default:\n          throw new Error('Unsupported lifecycle ' + lifecycle + '.');\n      }\n    } finally {\n      descriptor.pending = false;\n    }\n\n    if (instance == null && strict) {\n      throw new Error(typeToString(type, id) + ' failed to return a value in strict mode.');\n    }\n\n    return instance;\n  };\n\n  /**\n   * Returns a singleton instance.\n   *\n   * @param  {Object} descriptor\n   * @return {*}\n   */\n  var asSingleton = function (descriptor) {\n    var id = descriptor.id;\n\n    if (cache[id] == null) {\n      cache[id] = asTransient(descriptor);\n    }\n\n    return cache[id];\n  };\n\n  /**\n   * Creates a new instance.\n   *\n   * @param  {Object} descriptor\n   * @return {*}\n   */\n  var asTransient = function (descriptor) {\n    return descriptor.factory(api);\n  };\n\n  /**\n   * Creates a formated string from a type and id.\n   *\n   * @param  {*} type\n   * @param  {String=} uid\n   * @return {String}\n   */\n  var typeToString = function (type, uid) {\n    var result = type;\n\n    if (uid != null) {\n      result += '(' + uid + ')';\n    }\n\n    return result;\n  };\n\n  var api = {\n    bind: bind,\n    factory: factory,\n    instance: instance\n  };\n\n  return api;\n};\n\n/**\n * Creates a container compatible factory from a constructor of type T.\n *\n * @param  {Function} constructor\n * @param  {Array} dependencies\n * @return {Function}\n */\nvar asFactory = function (constructor, dependencies) {\n  return function (container) {\n    return construct(constructor, dependencies.map(function (dependency) {\n      return container.instance(dependency);\n    }));\n  };\n};\n\n/**\n * Creates a new object from its constructor.\n *\n * @param  {Function} constructor\n * @param  {Array=} params\n * @return {Object}\n */\nvar construct = function (constructor, params) {\n  return new (Function.bind.apply(constructor, [null].concat(params)))();\n};\n\n/**\n * Create a unique id for a dependency;\n *\n * @return {String}\n */\nvar uid = (function () {\n  var uid = 0;\n\n  var next = function () {\n    return ':' + uid++;\n  };\n\n  return next;\n})();\n\n/**\n * Slice array shortcut.\n *\n * @type {Function}\n */\nvar slice = Array.prototype.slice;\n\n/**\n * Has own property shortcut.\n *\n * @type {Function}\n */\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Brandy factory.\n *\n * @return {Container}\n */\nvar brandy = function () {\n  return new Container(new Mapping());\n};\n\n/**\n * Brandy build version.\n *\n * @type {String}\n */\nbrandy.version = '1.0.0';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return factory;\n    });\n  } else if (typeof exports === 'object' && module.exports) {\n    module.exports = factory;\n  } else {\n    global.Brandy = brandy;\n  }\n})(global, brandy);\n\n/**\n * Describes possible object lifecycles.\n *\n * @enum {String}\n */\nvar Lifecycle = {\n\n  /**\n   * Transient objects are created new every time its requested.\n   *\n   * @type {String}\n   */\n  TRANSIENT: 'TRANSIENT',\n\n  /**\n   * Singleton objects are only ever created once then cached.\n   *\n   * @type {String}\n   */\n  SINGLETON: 'SINGLETON',\n\n  /**\n   * Default lifecycle.\n   *\n   * @type {String}\n   */\n  DEFAULT: 'SINGLETON',\n\n  /**\n   * Parses a value to a valid enum type.\n   *\n   * @throws {Error} If unable to parse.\n   *\n   * @param  {String} value\n   * @return {String}\n   */\n  parse: function (value) {\n    if (typeof value == 'string') {\n      var name = value.toUpperCase();\n\n      if (has.call(Lifecycle, name) && typeof Lifecycle[name] === 'string') {\n        return Lifecycle[name];\n      }\n    }\n\n    throw new Error('Unable to parse ' + value + ' as Lifecycle.');\n  }\n};\n\n/**\n * Map like constructor. Mapping will attempt to delegate to native map if\n * supported.\n */\nvar Mapping = (function (root) {\n\n  /**\n   * Can we use native maps?\n   *\n   * @type {Boolean}\n   */\n  var NATIVE_MAP_SUPPORTED = 'Map' in global;\n\n  /**\n   * A thin and very incomplete map implementation for environments that\n   * dont support native maps.\n   */\n  var Mapping = function () {\n    var keys = [],\n        values = [];\n\n    /**\n     * Gets a value by key.\n     *\n     * @param  {*} key\n     * @return {*}\n     */\n    var get = function (key) {\n      return values[keys.indexOf(key)];\n    };\n\n    /**\n     * Sets a value by key.\n     *\n     * @param {*} key\n     * @param {*} value\n     * @return {Mapping}\n     */\n    var set = function (key, value) {\n      var index = keys.indexOf(key);\n\n      if (index === -1) {\n        keys.push(key);\n        values.push(value);\n      } else {\n        keys[index] = key;\n        values[index] = value;\n      }\n\n      return api;\n    };\n\n    /**\n     * Public api.\n     *\n     * @type {Object}\n     */\n    var api = {\n      get: get,\n      set: set\n    };\n\n    return api;\n  };\n\n  return NATIVE_MAP_SUPPORTED\n    ? global.Map\n    : Mapping;\n})(global);\n}(this));\n","/**\n * IoC container.\n *\n * @param {Mapping} map\n */\nvar Container = function (map) {\n\n  /**\n   * Internal cache for singleton instances.\n   *\n   * @type {Object}\n   */\n  var cache = {};\n\n  /**\n   * Binds a implementation to a type.\n   *\n   * @param  {*} type\n   * @param  {Function} implementation\n   * @param  {Object=} options\n   * @return {Container}\n   */\n  var bind = function (type, implementation, options) {\n    var bindingOptions = options || {},\n        dependencies = bindingOptions.dependencies || [],\n        lifecycle = bindingOptions.lifecycle;\n\n    if (typeof implementation !== 'function') {\n      throw new TypeError('Implementation must be a constructor.');\n    }\n\n    if (dependencies.constructor !== Array) {\n      throw new TypeError('Dependencies must be an array.');\n    }\n\n    return factory(type, asFactory(implementation, slice.call(dependencies)), lifecycle);\n  };\n\n  /**\n   * Binds a factory to a type.\n   *\n   * @param  {*} type\n   * @param  {Function(container: Container): *} factory\n   * @param  {Lifecycle} lifecycle\n   * @return {Container}\n   */\n  var factory = function (type, factory, lifecycle) {\n    if (typeof factory !== 'function') {\n      throw new TypeError('Factory must be a function.');\n    }\n\n    if (lifecycle != null && typeof lifecycle !== 'string') {\n      throw new TypeError('Lifecycle must be a string.');\n    }\n\n    map.set(type, {\n      factory: factory,\n      id: uid(),\n      lifecycle: Lifecycle.parse(lifecycle || Lifecycle.DEFAULT),\n      pending: false\n    });\n\n    return api;\n  };\n\n  /**\n   * Returns an instance bound to T. If the strict boolean is set, the return instance\n   * must be a non null or undefined value.\n   *\n   * @throws {Error} If dependency could not be resolved.\n   * @throws {Error} If a circular dependency is detected.\n   * @throws {Error} If an unsupported lifecycle is defined.\n   * @throws {Error} If strict is set, but the return instance did not reutrn a valid instance.\n   *\n   * @param  {*} type\n   * @param  {Boolean=} strict\n   * @return {*}\n   */\n  var instance = function (type, strict) {\n    var descriptor = map.get(type),\n        instance = null;\n\n    if (descriptor == null) {\n      throw new Error('Dependency ' + typeToString(type) + ' could not be resolved because it has not been registered.');\n    }\n\n    var id = descriptor.id,\n        lifecycle = descriptor.lifecycle;\n\n    if (descriptor.pending === true) {\n      throw new Error('Circular dependency detected while resolving ' + typeToString(type, id) + '.');\n    }\n\n    descriptor.pending = true;\n\n    try {\n      switch (lifecycle) {\n        case Lifecycle.SINGLETON:\n          instance = asSingleton(descriptor);\n          break;\n        case Lifecycle.TRANSIENT:\n          instance = asTransient(descriptor);\n          break;\n        default:\n          throw new Error('Unsupported lifecycle ' + lifecycle + '.');\n      }\n    } finally {\n      descriptor.pending = false;\n    }\n\n    if (instance == null && strict) {\n      throw new Error(typeToString(type, id) + ' failed to return a value in strict mode.');\n    }\n\n    return instance;\n  };\n\n  /**\n   * Returns a singleton instance.\n   *\n   * @param  {Object} descriptor\n   * @return {*}\n   */\n  var asSingleton = function (descriptor) {\n    var id = descriptor.id;\n\n    if (cache[id] == null) {\n      cache[id] = asTransient(descriptor);\n    }\n\n    return cache[id];\n  };\n\n  /**\n   * Creates a new instance.\n   *\n   * @param  {Object} descriptor\n   * @return {*}\n   */\n  var asTransient = function (descriptor) {\n    return descriptor.factory(api);\n  };\n\n  /**\n   * Creates a formated string from a type and id.\n   *\n   * @param  {*} type\n   * @param  {String=} uid\n   * @return {String}\n   */\n  var typeToString = function (type, uid) {\n    var result = type;\n\n    if (uid != null) {\n      result += '(' + uid + ')';\n    }\n\n    return result;\n  };\n\n  var api = {\n    bind: bind,\n    factory: factory,\n    instance: instance\n  };\n\n  return api;\n};\n","/**\n * Creates a container compatible factory from a constructor of type T.\n *\n * @param  {Function} constructor\n * @param  {Array} dependencies\n * @return {Function}\n */\nvar asFactory = function (constructor, dependencies) {\n  return function (container) {\n    return construct(constructor, dependencies.map(function (dependency) {\n      return container.instance(dependency);\n    }));\n  };\n};\n\n/**\n * Creates a new object from its constructor.\n *\n * @param  {Function} constructor\n * @param  {Array=} params\n * @return {Object}\n */\nvar construct = function (constructor, params) {\n  return new (Function.bind.apply(constructor, [null].concat(params)))();\n};\n\n/**\n * Create a unique id for a dependency;\n *\n * @return {String}\n */\nvar uid = (function () {\n  var uid = 0;\n\n  var next = function () {\n    return ':' + uid++;\n  };\n\n  return next;\n})();\n\n/**\n * Slice array shortcut.\n *\n * @type {Function}\n */\nvar slice = Array.prototype.slice;\n\n/**\n * Has own property shortcut.\n *\n * @type {Function}\n */\nvar has = Object.prototype.hasOwnProperty;\n","/**\n * Brandy factory.\n *\n * @return {Container}\n */\nvar brandy = function () {\n  return new Container(new Mapping());\n};\n\n/**\n * Brandy build version.\n *\n * @type {String}\n */\nbrandy.version = '<%= version %>';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return factory;\n    });\n  } else if (typeof exports === 'object' && module.exports) {\n    module.exports = factory;\n  } else {\n    global.Brandy = brandy;\n  }\n})(global, brandy);\n","/**\n * Describes possible object lifecycles.\n *\n * @enum {String}\n */\nvar Lifecycle = {\n\n  /**\n   * Transient objects are created new every time its requested.\n   *\n   * @type {String}\n   */\n  TRANSIENT: 'TRANSIENT',\n\n  /**\n   * Singleton objects are only ever created once then cached.\n   *\n   * @type {String}\n   */\n  SINGLETON: 'SINGLETON',\n\n  /**\n   * Default lifecycle.\n   *\n   * @type {String}\n   */\n  DEFAULT: 'SINGLETON',\n\n  /**\n   * Parses a value to a valid enum type.\n   *\n   * @throws {Error} If unable to parse.\n   *\n   * @param  {String} value\n   * @return {String}\n   */\n  parse: function (value) {\n    if (typeof value == 'string') {\n      var name = value.toUpperCase();\n\n      if (has.call(Lifecycle, name) && typeof Lifecycle[name] === 'string') {\n        return Lifecycle[name];\n      }\n    }\n\n    throw new Error('Unable to parse ' + value + ' as Lifecycle.');\n  }\n};\n","/**\n * Map like constructor. Mapping will attempt to delegate to native map if\n * supported.\n */\nvar Mapping = (function (root) {\n\n  /**\n   * Can we use native maps?\n   *\n   * @type {Boolean}\n   */\n  var NATIVE_MAP_SUPPORTED = 'Map' in global;\n\n  /**\n   * A thin and very incomplete map implementation for environments that\n   * dont support native maps.\n   */\n  var Mapping = function () {\n    var keys = [],\n        values = [];\n\n    /**\n     * Gets a value by key.\n     *\n     * @param  {*} key\n     * @return {*}\n     */\n    var get = function (key) {\n      return values[keys.indexOf(key)];\n    };\n\n    /**\n     * Sets a value by key.\n     *\n     * @param {*} key\n     * @param {*} value\n     * @return {Mapping}\n     */\n    var set = function (key, value) {\n      var index = keys.indexOf(key);\n\n      if (index === -1) {\n        keys.push(key);\n        values.push(value);\n      } else {\n        keys[index] = key;\n        values[index] = value;\n      }\n\n      return api;\n    };\n\n    /**\n     * Public api.\n     *\n     * @type {Object}\n     */\n    var api = {\n      get: get,\n      set: set\n    };\n\n    return api;\n  };\n\n  return NATIVE_MAP_SUPPORTED\n    ? global.Map\n    : Mapping;\n})(global);\n"],"sourceRoot":"/source/"}