{"version":3,"sources":["brandy.js","container.js","helpers.js","lifecycle.js","map.js","index.js"],"names":["global","Container","map","cache","bind","type","implementation","options","bindingOptions","dependencies","lifecycle","TypeError","constructor","Array","factory","asFactory","slice","call","set","id","uid","Lifecycle","parse","DEFAULT","pending","api","instance","strict","descriptor","get","Error","typeToString","SINGLETON","asSingleton","TRANSIENT","asTransient","keys","forEach","value","key","push","length","size","toString","result","getter","container","construct","dependency","params","Function","apply","concat","next","prototype","has","Object","hasOwnProperty","object","property","defineProperty","name","toUpperCase","Mapping","root","NATIVE_MAP_SUPPORTED","values","fn","index","indexOf","Map","brandy","version","define","amd","exports","module","Brandy","this"],"mappings":"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","file":"brandy.min.js","sourcesContent":["/**!\r\n * brandy 0.2.1 - A tiny IoC container.\r\n * http://www.github.com/rstone770/brandy\r\n *\r\n * Licensed MIT\r\n */\r\n;(function(global) {\n\"use strict\";\n\n/**\n * IoC container.\n *\n * @param {Mapping} map\n */\nvar Container = function (map) {\n\n  /**\n   * Internal cache for singleton instances.\n   *\n   * @type {Object}\n   */\n  var cache = {};\n\n  /**\n   * Binds a implementation to a type.\n   *\n   * @param  {*} type\n   * @param  {Function} implementation\n   * @param  {Object=} options\n   * @return {Container}\n   */\n  var bind = function (type, implementation, options) {\n    var bindingOptions = options || {},\n        dependencies = bindingOptions.dependencies || [],\n        lifecycle = bindingOptions.lifecycle;\n\n    if (typeof implementation !== 'function') {\n      throw new TypeError('Implementation must be a constructor.');\n    }\n\n    if (dependencies.constructor !== Array) {\n      throw new TypeError('Dependencies must be an array.');\n    }\n\n    return factory(type, asFactory(implementation, slice.call(dependencies)), lifecycle);\n  };\n\n  /**\n   * Binds a factory to a type.\n   *\n   * @param  {*} type\n   * @param  {Function(container: Container): *} factory\n   * @param  {Lifecycle} lifecycle\n   * @return {Container}\n   */\n  var factory = function (type, factory, lifecycle) {\n    if (typeof factory !== 'function') {\n      throw new TypeError('Factory must be a function.');\n    }\n\n    if (lifecycle != null && typeof lifecycle !== 'string') {\n      throw new TypeError('Lifecycle must be a string.');\n    }\n\n    map.set(type, {\n      factory: factory,\n      id: uid(),\n      lifecycle: Lifecycle.parse(lifecycle || Lifecycle.DEFAULT),\n      pending: false\n    });\n\n    return api;\n  };\n\n  /**\n   * Returns an instance bound to T. If the strict boolean is set, the return instance\n   * must be a non null or undefined value.\n   *\n   * @throws {Error} If dependency could not be resolved.\n   * @throws {Error} If a circular dependency is detected.\n   * @throws {Error} If an unsupported lifecycle is defined.\n   * @throws {Error} If strict is set, but the return instance did not reutrn a valid instance.\n   *\n   * @param  {*} type\n   * @param  {Boolean=} strict\n   * @return {*}\n   */\n  var instance = function (type, strict) {\n    var descriptor = map.get(type),\n        instance = null;\n\n    if (descriptor == null) {\n      throw new Error('Dependency ' + typeToString(type) + ' could not be resolved because it has not been registered.');\n    }\n\n    var id = descriptor.id,\n        lifecycle = descriptor.lifecycle;\n\n    if (descriptor.pending === true) {\n      throw new Error('Circular dependency detected while resolving ' + typeToString(type, id) + '.');\n    }\n\n    descriptor.pending = true;\n\n    try {\n      switch (lifecycle) {\n        case Lifecycle.SINGLETON:\n          instance = asSingleton(descriptor);\n          break;\n        case Lifecycle.TRANSIENT:\n          instance = asTransient(descriptor);\n          break;\n        default:\n          throw new Error('Unsupported lifecycle ' + lifecycle + '.');\n      }\n    } finally {\n      descriptor.pending = false;\n    }\n\n    if (instance == null && strict) {\n      throw new Error(typeToString(type, id) + ' failed to return a value in strict mode.');\n    }\n\n    return instance;\n  };\n\n  /**\n   * Determines the current keys in the container.\n   *\n   * @returns {object[]}\n   */\n  var keys = function () {\n    var keys = [];\n\n    map.forEach(function (value, key) {\n      keys.push(key);\n    });\n\n    return keys;\n  };\n\n  /**\n   * Determines the container size.\n   *\n   * @returns {Number}\n   */\n  var length = function () {\n    return map.size;\n  };\n\n  /**\n   * Returns a string object value of the container.\n   *\n   * @return {String}\n   */\n  var toString = function () {\n    return '[object Container]';\n  };\n\n  /**\n   * Returns a singleton instance.\n   *\n   * @param  {Object} descriptor\n   * @return {*}\n   */\n  var asSingleton = function (descriptor) {\n    var id = descriptor.id;\n\n    if (cache[id] == null) {\n      cache[id] = asTransient(descriptor);\n    }\n\n    return cache[id];\n  };\n\n  /**\n   * Creates a new instance.\n   *\n   * @param  {Object} descriptor\n   * @return {*}\n   */\n  var asTransient = function (descriptor) {\n    return descriptor.factory(api);\n  };\n\n  /**\n   * Creates a formated string from a type and id.\n   *\n   * @param  {*} type\n   * @param  {String=} uid\n   * @return {String}\n   */\n  var typeToString = function (type, uid) {\n    var result = type;\n\n    if (uid != null) {\n      result += '(' + uid + ')';\n    }\n\n    return result;\n  };\n\n  var api = {\n    bind: bind,\n    factory: factory,\n    instance: instance,\n    toString: toString\n  };\n\n  getter(api, 'keys', keys);\n  getter(api, 'length', length);\n\n  return api;\n};\n\n/**\n * Creates a container compatible factory from a constructor of type T.\n *\n * @param  {Function} constructor\n * @param  {Array} dependencies\n * @return {Function}\n */\nvar asFactory = function (constructor, dependencies) {\n  return function (container) {\n    return construct(constructor, dependencies.map(function (dependency) {\n      return container.instance(dependency);\n    }));\n  };\n};\n\n/**\n * Creates a new object from its constructor.\n *\n * @param  {Function} constructor\n * @param  {Array=} params\n * @return {Object}\n */\nvar construct = function (constructor, params) {\n  return new (Function.bind.apply(constructor, [null].concat(params)))();\n};\n\n/**\n * Create a unique id for a dependency;\n *\n * @return {String}\n */\nvar uid = (function () {\n  var uid = 0;\n\n  var next = function () {\n    return ':' + uid++;\n  };\n\n  return next;\n})();\n\n/**\n * Slice array shortcut.\n *\n * @type {Function}\n */\nvar slice = Array.prototype.slice;\n\n/**\n * Has own property shortcut.\n *\n * @type {Function}\n */\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Defines a getter on an object.\n *\n * @param {Object} object\n * @param {String} string\n * @param {Function} getter\n * @return {Object}\n */\nvar getter = function (object, property, getter) {\n  return Object.defineProperty(object, property, { get: getter });\n};\n\n/**\n * Describes possible object lifecycles.\n *\n * @enum {String}\n */\nvar Lifecycle = {\n\n  /**\n   * Transient objects are created new every time its requested.\n   *\n   * @type {String}\n   */\n  TRANSIENT: 'TRANSIENT',\n\n  /**\n   * Singleton objects are only ever created once then cached.\n   *\n   * @type {String}\n   */\n  SINGLETON: 'SINGLETON',\n\n  /**\n   * Default lifecycle.\n   *\n   * @type {String}\n   */\n  DEFAULT: 'SINGLETON',\n\n  /**\n   * Parses a value to a valid enum type.\n   *\n   * @throws {Error} If unable to parse.\n   *\n   * @param  {String} value\n   * @return {String}\n   */\n  parse: function (value) {\n    if (typeof value == 'string') {\n      var name = value.toUpperCase();\n\n      if (has.call(Lifecycle, name) && typeof Lifecycle[name] === 'string') {\n        return Lifecycle[name];\n      }\n    }\n\n    throw new Error('Unable to parse ' + value + ' as Lifecycle.');\n  }\n};\n\n/**\n * Map like constructor. Mapping will attempt to delegate to native map if\n * supported.\n */\nvar Mapping = (function (root) {\n\n  /**\n   * Can we use native maps?\n   *\n   * @type {Boolean}\n   */\n  var NATIVE_MAP_SUPPORTED = 'Map' in global;\n\n  /**\n   * A thin and very incomplete map implementation for environments that\n   * dont support native maps.\n   */\n  var Mapping = function () {\n    var keys = [],\n        values = [];\n\n    /**\n     * Iterates over key value pairs.\n     *\n     * @param {Function} fn\n     */\n    var forEach = function (fn) {\n      keys.forEach(function (key, index) {\n        fn(values[index], key);\n      });\n    };\n\n    /**\n     * Gets a value by key.\n     *\n     * @param  {*} key\n     * @return {*}\n     */\n    var get = function (key) {\n      return values[keys.indexOf(key)];\n    };\n\n    /**\n     * Sets a value by key.\n     *\n     * @param {*} key\n     * @param {*} value\n     * @return {Mapping}\n     */\n    var set = function (key, value) {\n      var index = keys.indexOf(key);\n\n      if (index === -1) {\n        keys.push(key);\n        values.push(value);\n      } else {\n        keys[index] = key;\n        values[index] = value;\n      }\n\n      return api;\n    };\n\n    /**\n     * Determines the size of the mapping.\n     *\n     * @returns {Number}\n     */\n    var size = function () {\n      return keys.length;\n    };\n\n    /**\n     * Public api.\n     *\n     * @type {Object}\n     */\n    var api = {\n      forEach: forEach,\n      get: get,\n      set: set\n    };\n\n    getter(api, 'size', size);\n\n    return api;\n  };\n\n  return NATIVE_MAP_SUPPORTED\n    ? global.Map\n    : Mapping;\n})(global);\n\n/**\n * Brandy factory.\n *\n * @return {Container}\n */\nvar brandy = function () {\n  return new Container(new Mapping());\n};\n\n/**\n * Global container.\n *\n * @return {Container}\n */\nbrandy.container = brandy();\n\n/**\n * Brandy build version.\n *\n * @type {String}\n */\nbrandy.version = '0.2.1';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return factory;\n    });\n  } else if (typeof exports === 'object' && module.exports) {\n    module.exports = factory;\n  } else {\n    global.Brandy = factory;\n  }\n})(global, brandy);\n}(this));\n","/**\n * IoC container.\n *\n * @param {Mapping} map\n */\nvar Container = function (map) {\n\n  /**\n   * Internal cache for singleton instances.\n   *\n   * @type {Object}\n   */\n  var cache = {};\n\n  /**\n   * Binds a implementation to a type.\n   *\n   * @param  {*} type\n   * @param  {Function} implementation\n   * @param  {Object=} options\n   * @return {Container}\n   */\n  var bind = function (type, implementation, options) {\n    var bindingOptions = options || {},\n        dependencies = bindingOptions.dependencies || [],\n        lifecycle = bindingOptions.lifecycle;\n\n    if (typeof implementation !== 'function') {\n      throw new TypeError('Implementation must be a constructor.');\n    }\n\n    if (dependencies.constructor !== Array) {\n      throw new TypeError('Dependencies must be an array.');\n    }\n\n    return factory(type, asFactory(implementation, slice.call(dependencies)), lifecycle);\n  };\n\n  /**\n   * Binds a factory to a type.\n   *\n   * @param  {*} type\n   * @param  {Function(container: Container): *} factory\n   * @param  {Lifecycle} lifecycle\n   * @return {Container}\n   */\n  var factory = function (type, factory, lifecycle) {\n    if (typeof factory !== 'function') {\n      throw new TypeError('Factory must be a function.');\n    }\n\n    if (lifecycle != null && typeof lifecycle !== 'string') {\n      throw new TypeError('Lifecycle must be a string.');\n    }\n\n    map.set(type, {\n      factory: factory,\n      id: uid(),\n      lifecycle: Lifecycle.parse(lifecycle || Lifecycle.DEFAULT),\n      pending: false\n    });\n\n    return api;\n  };\n\n  /**\n   * Returns an instance bound to T. If the strict boolean is set, the return instance\n   * must be a non null or undefined value.\n   *\n   * @throws {Error} If dependency could not be resolved.\n   * @throws {Error} If a circular dependency is detected.\n   * @throws {Error} If an unsupported lifecycle is defined.\n   * @throws {Error} If strict is set, but the return instance did not reutrn a valid instance.\n   *\n   * @param  {*} type\n   * @param  {Boolean=} strict\n   * @return {*}\n   */\n  var instance = function (type, strict) {\n    var descriptor = map.get(type),\n        instance = null;\n\n    if (descriptor == null) {\n      throw new Error('Dependency ' + typeToString(type) + ' could not be resolved because it has not been registered.');\n    }\n\n    var id = descriptor.id,\n        lifecycle = descriptor.lifecycle;\n\n    if (descriptor.pending === true) {\n      throw new Error('Circular dependency detected while resolving ' + typeToString(type, id) + '.');\n    }\n\n    descriptor.pending = true;\n\n    try {\n      switch (lifecycle) {\n        case Lifecycle.SINGLETON:\n          instance = asSingleton(descriptor);\n          break;\n        case Lifecycle.TRANSIENT:\n          instance = asTransient(descriptor);\n          break;\n        default:\n          throw new Error('Unsupported lifecycle ' + lifecycle + '.');\n      }\n    } finally {\n      descriptor.pending = false;\n    }\n\n    if (instance == null && strict) {\n      throw new Error(typeToString(type, id) + ' failed to return a value in strict mode.');\n    }\n\n    return instance;\n  };\n\n  /**\n   * Determines the current keys in the container.\n   *\n   * @returns {object[]}\n   */\n  var keys = function () {\n    var keys = [];\n\n    map.forEach(function (value, key) {\n      keys.push(key);\n    });\n\n    return keys;\n  };\n\n  /**\n   * Determines the container size.\n   *\n   * @returns {Number}\n   */\n  var length = function () {\n    return map.size;\n  };\n\n  /**\n   * Returns a string object value of the container.\n   *\n   * @return {String}\n   */\n  var toString = function () {\n    return '[object Container]';\n  };\n\n  /**\n   * Returns a singleton instance.\n   *\n   * @param  {Object} descriptor\n   * @return {*}\n   */\n  var asSingleton = function (descriptor) {\n    var id = descriptor.id;\n\n    if (cache[id] == null) {\n      cache[id] = asTransient(descriptor);\n    }\n\n    return cache[id];\n  };\n\n  /**\n   * Creates a new instance.\n   *\n   * @param  {Object} descriptor\n   * @return {*}\n   */\n  var asTransient = function (descriptor) {\n    return descriptor.factory(api);\n  };\n\n  /**\n   * Creates a formated string from a type and id.\n   *\n   * @param  {*} type\n   * @param  {String=} uid\n   * @return {String}\n   */\n  var typeToString = function (type, uid) {\n    var result = type;\n\n    if (uid != null) {\n      result += '(' + uid + ')';\n    }\n\n    return result;\n  };\n\n  var api = {\n    bind: bind,\n    factory: factory,\n    instance: instance,\n    toString: toString\n  };\n\n  getter(api, 'keys', keys);\n  getter(api, 'length', length);\n\n  return api;\n};\n","/**\n * Creates a container compatible factory from a constructor of type T.\n *\n * @param  {Function} constructor\n * @param  {Array} dependencies\n * @return {Function}\n */\nvar asFactory = function (constructor, dependencies) {\n  return function (container) {\n    return construct(constructor, dependencies.map(function (dependency) {\n      return container.instance(dependency);\n    }));\n  };\n};\n\n/**\n * Creates a new object from its constructor.\n *\n * @param  {Function} constructor\n * @param  {Array=} params\n * @return {Object}\n */\nvar construct = function (constructor, params) {\n  return new (Function.bind.apply(constructor, [null].concat(params)))();\n};\n\n/**\n * Create a unique id for a dependency;\n *\n * @return {String}\n */\nvar uid = (function () {\n  var uid = 0;\n\n  var next = function () {\n    return ':' + uid++;\n  };\n\n  return next;\n})();\n\n/**\n * Slice array shortcut.\n *\n * @type {Function}\n */\nvar slice = Array.prototype.slice;\n\n/**\n * Has own property shortcut.\n *\n * @type {Function}\n */\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Defines a getter on an object.\n *\n * @param {Object} object\n * @param {String} string\n * @param {Function} getter\n * @return {Object}\n */\nvar getter = function (object, property, getter) {\n  return Object.defineProperty(object, property, { get: getter });\n};\n","/**\n * Describes possible object lifecycles.\n *\n * @enum {String}\n */\nvar Lifecycle = {\n\n  /**\n   * Transient objects are created new every time its requested.\n   *\n   * @type {String}\n   */\n  TRANSIENT: 'TRANSIENT',\n\n  /**\n   * Singleton objects are only ever created once then cached.\n   *\n   * @type {String}\n   */\n  SINGLETON: 'SINGLETON',\n\n  /**\n   * Default lifecycle.\n   *\n   * @type {String}\n   */\n  DEFAULT: 'SINGLETON',\n\n  /**\n   * Parses a value to a valid enum type.\n   *\n   * @throws {Error} If unable to parse.\n   *\n   * @param  {String} value\n   * @return {String}\n   */\n  parse: function (value) {\n    if (typeof value == 'string') {\n      var name = value.toUpperCase();\n\n      if (has.call(Lifecycle, name) && typeof Lifecycle[name] === 'string') {\n        return Lifecycle[name];\n      }\n    }\n\n    throw new Error('Unable to parse ' + value + ' as Lifecycle.');\n  }\n};\n","/**\n * Map like constructor. Mapping will attempt to delegate to native map if\n * supported.\n */\nvar Mapping = (function (root) {\n\n  /**\n   * Can we use native maps?\n   *\n   * @type {Boolean}\n   */\n  var NATIVE_MAP_SUPPORTED = 'Map' in global;\n\n  /**\n   * A thin and very incomplete map implementation for environments that\n   * dont support native maps.\n   */\n  var Mapping = function () {\n    var keys = [],\n        values = [];\n\n    /**\n     * Iterates over key value pairs.\n     *\n     * @param {Function} fn\n     */\n    var forEach = function (fn) {\n      keys.forEach(function (key, index) {\n        fn(values[index], key);\n      });\n    };\n\n    /**\n     * Gets a value by key.\n     *\n     * @param  {*} key\n     * @return {*}\n     */\n    var get = function (key) {\n      return values[keys.indexOf(key)];\n    };\n\n    /**\n     * Sets a value by key.\n     *\n     * @param {*} key\n     * @param {*} value\n     * @return {Mapping}\n     */\n    var set = function (key, value) {\n      var index = keys.indexOf(key);\n\n      if (index === -1) {\n        keys.push(key);\n        values.push(value);\n      } else {\n        keys[index] = key;\n        values[index] = value;\n      }\n\n      return api;\n    };\n\n    /**\n     * Determines the size of the mapping.\n     *\n     * @returns {Number}\n     */\n    var size = function () {\n      return keys.length;\n    };\n\n    /**\n     * Public api.\n     *\n     * @type {Object}\n     */\n    var api = {\n      forEach: forEach,\n      get: get,\n      set: set\n    };\n\n    getter(api, 'size', size);\n\n    return api;\n  };\n\n  return NATIVE_MAP_SUPPORTED\n    ? global.Map\n    : Mapping;\n})(global);\n","/**\n * Brandy factory.\n *\n * @return {Container}\n */\nvar brandy = function () {\n  return new Container(new Mapping());\n};\n\n/**\n * Global container.\n *\n * @return {Container}\n */\nbrandy.container = brandy();\n\n/**\n * Brandy build version.\n *\n * @type {String}\n */\nbrandy.version = '<%= version %>';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return factory;\n    });\n  } else if (typeof exports === 'object' && module.exports) {\n    module.exports = factory;\n  } else {\n    global.Brandy = factory;\n  }\n})(global, brandy);\n"],"sourceRoot":"/source/"}