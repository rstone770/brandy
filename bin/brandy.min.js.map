{"version":3,"sources":["brandy.js","container.js","helpers.js","index.js","lifecycle.js","map.js"],"names":["global","formatTypeString","T","uid","string","Container","map","this","_map","_cache","prototype","bind","implementation","options","bindingOptions","dependencies","lifecycle","Error","constructor","Array","factory","asFactory","slice","call","set","id","Lifecycle","parse","DEFAULT","pending","instance","strict","descriptor","get","SINGLETON","_singleton","TRANSIENT","_transient","container","construct","dependency","params","Function","apply","concat","next","has","Object","hasOwnProperty","brandy","Mapping","version","root","define","amd","exports","module","Brandy","value","result","name","toUpperCase","NATIVE_MAP_SUPPORTED","_keys","_values","key","indexOf","index","push","Map"],"mappings":"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","file":"brandy.min.js","sourcesContent":["/**!\n * brandy 1.0.0 - A tiny IoC container.\n * http://www.github.com/rstone770/brandy\n *\n * Licensed MIT\n */\n;(function(global) {\n\"use strict\";\n\n/**\n * Creates a formated string from a type and id.\n *\n * @param  {T} T\n * @param  {String} uid\n * @return {String}\n */\nvar formatTypeString = function (T, uid) {\n  var string = T;\n\n  if (uid != null) {\n    string += '(' + uid + ')';\n  }\n\n  return string;\n};\n\n/**\n * IoC container.\n *\n * @param {Mapping} map\n */\nvar Container = function (map) {\n  this._map = map;\n  this._cache = {};\n};\n\n/**\n * IoC prototype.\n */\nContainer.prototype = {\n\n  /**\n   * Binds a implementation to a type.\n   *\n   * @param  {T} T\n   * @param  {U} implementation\n   * @param  {Object=} options\n   * @return {Container}\n   */\n  bind: function (T, implementation, options) {\n    var bindingOptions = options || {},\n        dependencies = bindingOptions.dependencies || [],\n        lifecycle = bindingOptions.lifecycle;\n\n    if (typeof implementation !== 'function') {\n      throw new Error('Implementation must be a constructor.');\n    }\n\n    if (dependencies.constructor !== Array) {\n      throw new Error('Dependencies must be an array.');\n    }\n\n    return this.factory(T, asFactory(implementation, slice.call(bindingOptions.dependencies)), lifecycle);\n  },\n\n  /**\n   * Binds a factory to a type.\n   *\n   * @param  {T} T\n   * @param  {Function(container: Container): U} factory\n   * @param  {Lifecycle} lifecycle\n   * @return {Container}\n   */\n  factory: function (T, factory, lifecycle) {\n    if (typeof factory !== 'function') {\n      throw new Error('Factory must be a function.');\n    }\n\n    if (lifecycle != null && typeof lifecycle !== 'string') {\n      throw new Error('Lifecycle must be a string.');\n    }\n\n    this._map.set(T, {\n      factory: factory,\n      id: uid(),\n      lifecycle: Lifecycle.parse(lifecycle || Lifecycle.DEFAULT),\n      pending: false\n    });\n\n    return this;\n  },\n\n  /**\n   * Returns an instance bound to T. If the strict boolean is set, the return instance\n   * must be a non null or undefined value.\n   *\n   * @throws {Error} If dependency could not be resolved.\n   * @throws {Error} If a circular dependency is detected.\n   * @throws {Error} If an unsupported lifecycle is defined.\n   * @throws {Error} If strict is set, but the return instance did not reutrn a valid instance.\n   *\n   * @param  {T} T\n   * @param  {Boolean=} strict\n   * @return {U}\n   */\n  instance: function (T, strict) {\n    var descriptor = this._map.get(T),\n        instance = null;\n\n    if (descriptor == null) {\n      throw new Error('Dependency ' + formatTypeString(T) + ' could not be resolved because it has not been registered.');\n    }\n\n    if (descriptor.pending === true) {\n      throw new Error('Circular dependency detected while resolving ' + formatTypeString(T, descriptor.id) + '.');\n    }\n\n    descriptor.pending = true;\n\n    try {\n      switch (descriptor.lifecycle) {\n        case Lifecycle.SINGLETON:\n          instance = this._singleton(descriptor);\n          break;\n        case Lifecycle.TRANSIENT:\n          instance = this._transient(descriptor);\n          break;\n        default:\n          throw new Error('Unsupported lifecycle ' + descriptor.lifecycle + '.');\n      }\n    } finally {\n      descriptor.pending = false;\n    }\n\n    if (instance == null && strict) {\n      throw new Error(formatTypeString(T, descriptor.id) + ' did not return a value.');\n    }\n\n    return instance;\n  },\n\n  /**\n   * Returns a singleton instance.\n   *\n   * @param  {Object} descriptor\n   * @return {T}\n   */\n  _singleton: function (descriptor) {\n    if (this._cache[descriptor.id] == null) {\n      this._cache[descriptor.id] = this._transient(descriptor);\n    }\n\n    return this._cache[descriptor.id];\n  },\n\n  /**\n   * Returns a new instance.\n   *\n   * @param  {Object} descriptor\n   * @return {T}\n   */\n  _transient: function (descriptor) {\n    return descriptor.factory(this);\n  }\n};\n\n/**\n * Creates a container compatible factory from a constructor of type T.\n *\n * @param  {T} T\n * @param  {Array} dependencies\n * @return {Function}\n */\nvar asFactory = function (T, dependencies) {\n  return function (container) {\n    return construct(T, dependencies.map(function (dependency) {\n      return container.instance(dependency);\n    }));\n  };\n};\n\n/**\n * Creates a new object from its constructor.\n *\n * @param  {T} T\n * @param  {Array=} params\n * @return {T}\n */\nvar construct = function (T, params) {\n  return new (Function.bind.apply(T, [null].concat(params)))();\n};\n\n/**\n * Create a unique id for a dependency;\n *\n * @return {String}\n */\nvar uid = (function () {\n  var uid = 0;\n\n  var next = function () {\n    return ':' + uid++;\n  };\n\n  return next;\n})();\n\n/**\n * Slice array shortcut.\n *\n * @type {Function}\n */\nvar slice = Array.prototype.slice;\n\n/**\n * Has own property shortcut.\n *\n * @type {Function}\n */\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Brandy factory.\n *\n * @return {Container}\n */\nvar brandy = function () {\n  return new Container(new Mapping());\n};\n\n/**\n * Brandy build version.\n *\n * @type {String}\n */\nbrandy.version = '1.0.0';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return factory;\n    });\n  } else if (typeof exports === 'object' && module.exports) {\n    module.exports = factory;\n  } else {\n    global.Brandy = brandy;\n  }\n})(global, brandy);\n\n/**\n * Describes possible object lifecycles.\n *\n * @enum {String}\n */\nvar Lifecycle = {\n\n  /**\n   * Transient objects are created new every time its requested.\n   *\n   * @type {String}\n   */\n  TRANSIENT: 'TRANSIENT',\n\n  /**\n   * Singleton objects are only ever created once then cached.\n   *\n   * @type {String}\n   */\n  SINGLETON: 'SINGLETON',\n\n  /**\n   * Default lifecycle.\n   *\n   * @type {String}\n   */\n  DEFAULT: 'SINGLETON',\n\n  /**\n   * Parses a value to a valid enum type.\n   *\n   * @throws {Error} If unable to parse.\n   *\n   * @param  {String} value\n   * @return {String}\n   */\n  parse: function (value) {\n    var result = null;\n\n    if (typeof value == 'string') {\n      var name = value.toUpperCase();\n\n      if (has.call(this, name) && typeof this[name] === 'string') {\n        if (this[name] === name) {\n          result = this[name];\n        } else {\n          result = this.parse(this[name]);\n        }\n      }\n    }\n\n    if (result == null) {\n      throw new Error('Unable to parse ' + value + ' as Lifecycle.');\n    }\n\n    return result;\n  }\n};\n\n/**\n * Map like constructor. Mapping will attempt to delegate to native map if\n * supported.\n */\nvar Mapping = (function (root) {\n\n  /**\n   * Can we use native maps?\n   *\n   * @type {Boolean}\n   */\n  var NATIVE_MAP_SUPPORTED = 'Map' in global;\n\n  /**\n   * A thin and very incomplete map implementation for environments that\n   * dont support native maps.\n   */\n  var Mapping = function () {\n    this._keys = [];\n    this._values = [];\n  };\n\n  /**\n   * Map prototype.\n   */\n  Mapping.prototype = {\n\n    /**\n     * Gets a single value from the map.\n     *\n     * @param  {T} key\n     * @return {U}\n     */\n    get: function (key) {\n      return this._values[this._keys.indexOf(key)];\n    },\n\n    /**\n     * Sets a single value from the map.\n     *\n     * @param  {T} key   [description]\n     * @param  {U} value [description]\n     * @return {Map}       [description]\n     */\n    set: function (key, value) {\n      var index = this._keys.indexOf(key);\n\n      if (index === -1) {\n        this._keys.push(key);\n        this._values.push(value);\n      } else {\n        this._keys[index] = key;\n        this._values[index] = value;\n      }\n\n      return this;\n    }\n  };\n\n  return NATIVE_MAP_SUPPORTED\n    ? global.Map\n    : Mapping;\n})(global);\n}(this));\n","/**\n * Creates a formated string from a type and id.\n *\n * @param  {T} T\n * @param  {String} uid\n * @return {String}\n */\nvar formatTypeString = function (T, uid) {\n  var string = T;\n\n  if (uid != null) {\n    string += '(' + uid + ')';\n  }\n\n  return string;\n};\n\n/**\n * IoC container.\n *\n * @param {Mapping} map\n */\nvar Container = function (map) {\n  this._map = map;\n  this._cache = {};\n};\n\n/**\n * IoC prototype.\n */\nContainer.prototype = {\n\n  /**\n   * Binds a implementation to a type.\n   *\n   * @param  {T} T\n   * @param  {U} implementation\n   * @param  {Object=} options\n   * @return {Container}\n   */\n  bind: function (T, implementation, options) {\n    var bindingOptions = options || {},\n        dependencies = bindingOptions.dependencies || [],\n        lifecycle = bindingOptions.lifecycle;\n\n    if (typeof implementation !== 'function') {\n      throw new Error('Implementation must be a constructor.');\n    }\n\n    if (dependencies.constructor !== Array) {\n      throw new Error('Dependencies must be an array.');\n    }\n\n    return this.factory(T, asFactory(implementation, slice.call(bindingOptions.dependencies)), lifecycle);\n  },\n\n  /**\n   * Binds a factory to a type.\n   *\n   * @param  {T} T\n   * @param  {Function(container: Container): U} factory\n   * @param  {Lifecycle} lifecycle\n   * @return {Container}\n   */\n  factory: function (T, factory, lifecycle) {\n    if (typeof factory !== 'function') {\n      throw new Error('Factory must be a function.');\n    }\n\n    if (lifecycle != null && typeof lifecycle !== 'string') {\n      throw new Error('Lifecycle must be a string.');\n    }\n\n    this._map.set(T, {\n      factory: factory,\n      id: uid(),\n      lifecycle: Lifecycle.parse(lifecycle || Lifecycle.DEFAULT),\n      pending: false\n    });\n\n    return this;\n  },\n\n  /**\n   * Returns an instance bound to T. If the strict boolean is set, the return instance\n   * must be a non null or undefined value.\n   *\n   * @throws {Error} If dependency could not be resolved.\n   * @throws {Error} If a circular dependency is detected.\n   * @throws {Error} If an unsupported lifecycle is defined.\n   * @throws {Error} If strict is set, but the return instance did not reutrn a valid instance.\n   *\n   * @param  {T} T\n   * @param  {Boolean=} strict\n   * @return {U}\n   */\n  instance: function (T, strict) {\n    var descriptor = this._map.get(T),\n        instance = null;\n\n    if (descriptor == null) {\n      throw new Error('Dependency ' + formatTypeString(T) + ' could not be resolved because it has not been registered.');\n    }\n\n    if (descriptor.pending === true) {\n      throw new Error('Circular dependency detected while resolving ' + formatTypeString(T, descriptor.id) + '.');\n    }\n\n    descriptor.pending = true;\n\n    try {\n      switch (descriptor.lifecycle) {\n        case Lifecycle.SINGLETON:\n          instance = this._singleton(descriptor);\n          break;\n        case Lifecycle.TRANSIENT:\n          instance = this._transient(descriptor);\n          break;\n        default:\n          throw new Error('Unsupported lifecycle ' + descriptor.lifecycle + '.');\n      }\n    } finally {\n      descriptor.pending = false;\n    }\n\n    if (instance == null && strict) {\n      throw new Error(formatTypeString(T, descriptor.id) + ' did not return a value.');\n    }\n\n    return instance;\n  },\n\n  /**\n   * Returns a singleton instance.\n   *\n   * @param  {Object} descriptor\n   * @return {T}\n   */\n  _singleton: function (descriptor) {\n    if (this._cache[descriptor.id] == null) {\n      this._cache[descriptor.id] = this._transient(descriptor);\n    }\n\n    return this._cache[descriptor.id];\n  },\n\n  /**\n   * Returns a new instance.\n   *\n   * @param  {Object} descriptor\n   * @return {T}\n   */\n  _transient: function (descriptor) {\n    return descriptor.factory(this);\n  }\n};\n","/**\n * Creates a container compatible factory from a constructor of type T.\n *\n * @param  {T} T\n * @param  {Array} dependencies\n * @return {Function}\n */\nvar asFactory = function (T, dependencies) {\n  return function (container) {\n    return construct(T, dependencies.map(function (dependency) {\n      return container.instance(dependency);\n    }));\n  };\n};\n\n/**\n * Creates a new object from its constructor.\n *\n * @param  {T} T\n * @param  {Array=} params\n * @return {T}\n */\nvar construct = function (T, params) {\n  return new (Function.bind.apply(T, [null].concat(params)))();\n};\n\n/**\n * Create a unique id for a dependency;\n *\n * @return {String}\n */\nvar uid = (function () {\n  var uid = 0;\n\n  var next = function () {\n    return ':' + uid++;\n  };\n\n  return next;\n})();\n\n/**\n * Slice array shortcut.\n *\n * @type {Function}\n */\nvar slice = Array.prototype.slice;\n\n/**\n * Has own property shortcut.\n *\n * @type {Function}\n */\nvar has = Object.prototype.hasOwnProperty;\n","/**\n * Brandy factory.\n *\n * @return {Container}\n */\nvar brandy = function () {\n  return new Container(new Mapping());\n};\n\n/**\n * Brandy build version.\n *\n * @type {String}\n */\nbrandy.version = '<%= version %>';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return factory;\n    });\n  } else if (typeof exports === 'object' && module.exports) {\n    module.exports = factory;\n  } else {\n    global.Brandy = brandy;\n  }\n})(global, brandy);\n","/**\n * Describes possible object lifecycles.\n *\n * @enum {String}\n */\nvar Lifecycle = {\n\n  /**\n   * Transient objects are created new every time its requested.\n   *\n   * @type {String}\n   */\n  TRANSIENT: 'TRANSIENT',\n\n  /**\n   * Singleton objects are only ever created once then cached.\n   *\n   * @type {String}\n   */\n  SINGLETON: 'SINGLETON',\n\n  /**\n   * Default lifecycle.\n   *\n   * @type {String}\n   */\n  DEFAULT: 'SINGLETON',\n\n  /**\n   * Parses a value to a valid enum type.\n   *\n   * @throws {Error} If unable to parse.\n   *\n   * @param  {String} value\n   * @return {String}\n   */\n  parse: function (value) {\n    var result = null;\n\n    if (typeof value == 'string') {\n      var name = value.toUpperCase();\n\n      if (has.call(this, name) && typeof this[name] === 'string') {\n        if (this[name] === name) {\n          result = this[name];\n        } else {\n          result = this.parse(this[name]);\n        }\n      }\n    }\n\n    if (result == null) {\n      throw new Error('Unable to parse ' + value + ' as Lifecycle.');\n    }\n\n    return result;\n  }\n};\n","/**\n * Map like constructor. Mapping will attempt to delegate to native map if\n * supported.\n */\nvar Mapping = (function (root) {\n\n  /**\n   * Can we use native maps?\n   *\n   * @type {Boolean}\n   */\n  var NATIVE_MAP_SUPPORTED = 'Map' in global;\n\n  /**\n   * A thin and very incomplete map implementation for environments that\n   * dont support native maps.\n   */\n  var Mapping = function () {\n    this._keys = [];\n    this._values = [];\n  };\n\n  /**\n   * Map prototype.\n   */\n  Mapping.prototype = {\n\n    /**\n     * Gets a single value from the map.\n     *\n     * @param  {T} key\n     * @return {U}\n     */\n    get: function (key) {\n      return this._values[this._keys.indexOf(key)];\n    },\n\n    /**\n     * Sets a single value from the map.\n     *\n     * @param  {T} key   [description]\n     * @param  {U} value [description]\n     * @return {Map}       [description]\n     */\n    set: function (key, value) {\n      var index = this._keys.indexOf(key);\n\n      if (index === -1) {\n        this._keys.push(key);\n        this._values.push(value);\n      } else {\n        this._keys[index] = key;\n        this._values[index] = value;\n      }\n\n      return this;\n    }\n  };\n\n  return NATIVE_MAP_SUPPORTED\n    ? global.Map\n    : Mapping;\n})(global);\n"],"sourceRoot":"/source/"}