{"version":3,"sources":["brandy.js","container.js","helpers.js","index.js","lifecycle.js","map.js"],"names":["global","Container","map","cache","bind","type","implementation","options","bindingOptions","dependencies","lifecycle","TypeError","constructor","Array","factory","asFactory","slice","call","set","id","uid","Lifecycle","parse","DEFAULT","pending","api","instance","strict","descriptor","get","Error","typeToString","SINGLETON","asSingleton","TRANSIENT","asTransient","result","container","construct","dependency","params","Function","apply","concat","next","prototype","has","Object","hasOwnProperty","brandy","Mapping","version","root","define","amd","exports","module","Brandy","value","name","toUpperCase","NATIVE_MAP_SUPPORTED","keys","values","key","indexOf","index","push","Map","this"],"mappings":"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","file":"brandy.min.js","sourcesContent":["/**!\r\n * brandy 0.0.1 - A tiny IoC container.\r\n * http://www.github.com/rstone770/brandy\r\n *\r\n * Licensed MIT\r\n */\r\n;(function(global) {\n\"use strict\";\n\n/**\r\n * IoC container.\r\n *\r\n * @param {Mapping} map\r\n */\r\nvar Container = function (map) {\r\n\r\n  /**\r\n   * Internal cache for singleton instances.\r\n   *\r\n   * @type {Object}\r\n   */\r\n  var cache = {};\r\n\r\n  /**\r\n   * Binds a implementation to a type.\r\n   *\r\n   * @param  {*} type\r\n   * @param  {Function} implementation\r\n   * @param  {Object=} options\r\n   * @return {Container}\r\n   */\r\n  var bind = function (type, implementation, options) {\r\n    var bindingOptions = options || {},\r\n        dependencies = bindingOptions.dependencies || [],\r\n        lifecycle = bindingOptions.lifecycle;\r\n\r\n    if (typeof implementation !== 'function') {\r\n      throw new TypeError('Implementation must be a constructor.');\r\n    }\r\n\r\n    if (dependencies.constructor !== Array) {\r\n      throw new TypeError('Dependencies must be an array.');\r\n    }\r\n\r\n    return factory(type, asFactory(implementation, slice.call(dependencies)), lifecycle);\r\n  };\r\n\r\n  /**\r\n   * Binds a factory to a type.\r\n   *\r\n   * @param  {*} type\r\n   * @param  {Function(container: Container): *} factory\r\n   * @param  {Lifecycle} lifecycle\r\n   * @return {Container}\r\n   */\r\n  var factory = function (type, factory, lifecycle) {\r\n    if (typeof factory !== 'function') {\r\n      throw new TypeError('Factory must be a function.');\r\n    }\r\n\r\n    if (lifecycle != null && typeof lifecycle !== 'string') {\r\n      throw new TypeError('Lifecycle must be a string.');\r\n    }\r\n\r\n    map.set(type, {\r\n      factory: factory,\r\n      id: uid(),\r\n      lifecycle: Lifecycle.parse(lifecycle || Lifecycle.DEFAULT),\r\n      pending: false\r\n    });\r\n\r\n    return api;\r\n  };\r\n\r\n  /**\r\n   * Returns an instance bound to T. If the strict boolean is set, the return instance\r\n   * must be a non null or undefined value.\r\n   *\r\n   * @throws {Error} If dependency could not be resolved.\r\n   * @throws {Error} If a circular dependency is detected.\r\n   * @throws {Error} If an unsupported lifecycle is defined.\r\n   * @throws {Error} If strict is set, but the return instance did not reutrn a valid instance.\r\n   *\r\n   * @param  {*} type\r\n   * @param  {Boolean=} strict\r\n   * @return {*}\r\n   */\r\n  var instance = function (type, strict) {\r\n    var descriptor = map.get(type),\r\n        instance = null;\r\n\r\n    if (descriptor == null) {\r\n      throw new Error('Dependency ' + typeToString(type) + ' could not be resolved because it has not been registered.');\r\n    }\r\n\r\n    var id = descriptor.id,\r\n        lifecycle = descriptor.lifecycle;\r\n\r\n    if (descriptor.pending === true) {\r\n      throw new Error('Circular dependency detected while resolving ' + typeToString(type, id) + '.');\r\n    }\r\n\r\n    descriptor.pending = true;\r\n\r\n    try {\r\n      switch (lifecycle) {\r\n        case Lifecycle.SINGLETON:\r\n          instance = asSingleton(descriptor);\r\n          break;\r\n        case Lifecycle.TRANSIENT:\r\n          instance = asTransient(descriptor);\r\n          break;\r\n        default:\r\n          throw new Error('Unsupported lifecycle ' + lifecycle + '.');\r\n      }\r\n    } finally {\r\n      descriptor.pending = false;\r\n    }\r\n\r\n    if (instance == null && strict) {\r\n      throw new Error(typeToString(type, id) + ' failed to return a value in strict mode.');\r\n    }\r\n\r\n    return instance;\r\n  };\r\n\r\n  /**\r\n   * Returns a singleton instance.\r\n   *\r\n   * @param  {Object} descriptor\r\n   * @return {*}\r\n   */\r\n  var asSingleton = function (descriptor) {\r\n    var id = descriptor.id;\r\n\r\n    if (cache[id] == null) {\r\n      cache[id] = asTransient(descriptor);\r\n    }\r\n\r\n    return cache[id];\r\n  };\r\n\r\n  /**\r\n   * Creates a new instance.\r\n   *\r\n   * @param  {Object} descriptor\r\n   * @return {*}\r\n   */\r\n  var asTransient = function (descriptor) {\r\n    return descriptor.factory(api);\r\n  };\r\n\r\n  /**\r\n   * Creates a formated string from a type and id.\r\n   *\r\n   * @param  {*} type\r\n   * @param  {String=} uid\r\n   * @return {String}\r\n   */\r\n  var typeToString = function (type, uid) {\r\n    var result = type;\r\n\r\n    if (uid != null) {\r\n      result += '(' + uid + ')';\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  var api = {\r\n    bind: bind,\r\n    factory: factory,\r\n    instance: instance\r\n  };\r\n\r\n  return api;\r\n};\r\n\n/**\r\n * Creates a container compatible factory from a constructor of type T.\r\n *\r\n * @param  {Function} constructor\r\n * @param  {Array} dependencies\r\n * @return {Function}\r\n */\r\nvar asFactory = function (constructor, dependencies) {\r\n  return function (container) {\r\n    return construct(constructor, dependencies.map(function (dependency) {\r\n      return container.instance(dependency);\r\n    }));\r\n  };\r\n};\r\n\r\n/**\r\n * Creates a new object from its constructor.\r\n *\r\n * @param  {Function} constructor\r\n * @param  {Array=} params\r\n * @return {Object}\r\n */\r\nvar construct = function (constructor, params) {\r\n  return new (Function.bind.apply(constructor, [null].concat(params)))();\r\n};\r\n\r\n/**\r\n * Create a unique id for a dependency;\r\n *\r\n * @return {String}\r\n */\r\nvar uid = (function () {\r\n  var uid = 0;\r\n\r\n  var next = function () {\r\n    return ':' + uid++;\r\n  };\r\n\r\n  return next;\r\n})();\r\n\r\n/**\r\n * Slice array shortcut.\r\n *\r\n * @type {Function}\r\n */\r\nvar slice = Array.prototype.slice;\r\n\r\n/**\r\n * Has own property shortcut.\r\n *\r\n * @type {Function}\r\n */\r\nvar has = Object.prototype.hasOwnProperty;\r\n\n/**\r\n * Brandy factory.\r\n *\r\n * @return {Container}\r\n */\r\nvar brandy = function () {\r\n  return new Container(new Mapping());\r\n};\r\n\r\n/**\r\n * Brandy build version.\r\n *\r\n * @type {String}\r\n */\r\nbrandy.version = '0.0.1';\r\n\r\n(function (root, factory) {\r\n  if (typeof define === 'function' && define.amd) {\r\n    define(function () {\r\n      return factory;\r\n    });\r\n  } else if (typeof exports === 'object' && module.exports) {\r\n    module.exports = factory;\r\n  } else {\r\n    global.Brandy = factory;\r\n  }\r\n})(global, brandy);\r\n\n/**\r\n * Describes possible object lifecycles.\r\n *\r\n * @enum {String}\r\n */\r\nvar Lifecycle = {\r\n\r\n  /**\r\n   * Transient objects are created new every time its requested.\r\n   *\r\n   * @type {String}\r\n   */\r\n  TRANSIENT: 'TRANSIENT',\r\n\r\n  /**\r\n   * Singleton objects are only ever created once then cached.\r\n   *\r\n   * @type {String}\r\n   */\r\n  SINGLETON: 'SINGLETON',\r\n\r\n  /**\r\n   * Default lifecycle.\r\n   *\r\n   * @type {String}\r\n   */\r\n  DEFAULT: 'SINGLETON',\r\n\r\n  /**\r\n   * Parses a value to a valid enum type.\r\n   *\r\n   * @throws {Error} If unable to parse.\r\n   *\r\n   * @param  {String} value\r\n   * @return {String}\r\n   */\r\n  parse: function (value) {\r\n    if (typeof value == 'string') {\r\n      var name = value.toUpperCase();\r\n\r\n      if (has.call(Lifecycle, name) && typeof Lifecycle[name] === 'string') {\r\n        return Lifecycle[name];\r\n      }\r\n    }\r\n\r\n    throw new Error('Unable to parse ' + value + ' as Lifecycle.');\r\n  }\r\n};\r\n\n/**\r\n * Map like constructor. Mapping will attempt to delegate to native map if\r\n * supported.\r\n */\r\nvar Mapping = (function (root) {\r\n\r\n  /**\r\n   * Can we use native maps?\r\n   *\r\n   * @type {Boolean}\r\n   */\r\n  var NATIVE_MAP_SUPPORTED = 'Map' in global;\r\n\r\n  /**\r\n   * A thin and very incomplete map implementation for environments that\r\n   * dont support native maps.\r\n   */\r\n  var Mapping = function () {\r\n    var keys = [],\r\n        values = [];\r\n\r\n    /**\r\n     * Gets a value by key.\r\n     *\r\n     * @param  {*} key\r\n     * @return {*}\r\n     */\r\n    var get = function (key) {\r\n      return values[keys.indexOf(key)];\r\n    };\r\n\r\n    /**\r\n     * Sets a value by key.\r\n     *\r\n     * @param {*} key\r\n     * @param {*} value\r\n     * @return {Mapping}\r\n     */\r\n    var set = function (key, value) {\r\n      var index = keys.indexOf(key);\r\n\r\n      if (index === -1) {\r\n        keys.push(key);\r\n        values.push(value);\r\n      } else {\r\n        keys[index] = key;\r\n        values[index] = value;\r\n      }\r\n\r\n      return api;\r\n    };\r\n\r\n    /**\r\n     * Public api.\r\n     *\r\n     * @type {Object}\r\n     */\r\n    var api = {\r\n      get: get,\r\n      set: set\r\n    };\r\n\r\n    return api;\r\n  };\r\n\r\n  return NATIVE_MAP_SUPPORTED\r\n    ? global.Map\r\n    : Mapping;\r\n})(global);\n}(this));\n","/**\r\n * IoC container.\r\n *\r\n * @param {Mapping} map\r\n */\r\nvar Container = function (map) {\r\n\r\n  /**\r\n   * Internal cache for singleton instances.\r\n   *\r\n   * @type {Object}\r\n   */\r\n  var cache = {};\r\n\r\n  /**\r\n   * Binds a implementation to a type.\r\n   *\r\n   * @param  {*} type\r\n   * @param  {Function} implementation\r\n   * @param  {Object=} options\r\n   * @return {Container}\r\n   */\r\n  var bind = function (type, implementation, options) {\r\n    var bindingOptions = options || {},\r\n        dependencies = bindingOptions.dependencies || [],\r\n        lifecycle = bindingOptions.lifecycle;\r\n\r\n    if (typeof implementation !== 'function') {\r\n      throw new TypeError('Implementation must be a constructor.');\r\n    }\r\n\r\n    if (dependencies.constructor !== Array) {\r\n      throw new TypeError('Dependencies must be an array.');\r\n    }\r\n\r\n    return factory(type, asFactory(implementation, slice.call(dependencies)), lifecycle);\r\n  };\r\n\r\n  /**\r\n   * Binds a factory to a type.\r\n   *\r\n   * @param  {*} type\r\n   * @param  {Function(container: Container): *} factory\r\n   * @param  {Lifecycle} lifecycle\r\n   * @return {Container}\r\n   */\r\n  var factory = function (type, factory, lifecycle) {\r\n    if (typeof factory !== 'function') {\r\n      throw new TypeError('Factory must be a function.');\r\n    }\r\n\r\n    if (lifecycle != null && typeof lifecycle !== 'string') {\r\n      throw new TypeError('Lifecycle must be a string.');\r\n    }\r\n\r\n    map.set(type, {\r\n      factory: factory,\r\n      id: uid(),\r\n      lifecycle: Lifecycle.parse(lifecycle || Lifecycle.DEFAULT),\r\n      pending: false\r\n    });\r\n\r\n    return api;\r\n  };\r\n\r\n  /**\r\n   * Returns an instance bound to T. If the strict boolean is set, the return instance\r\n   * must be a non null or undefined value.\r\n   *\r\n   * @throws {Error} If dependency could not be resolved.\r\n   * @throws {Error} If a circular dependency is detected.\r\n   * @throws {Error} If an unsupported lifecycle is defined.\r\n   * @throws {Error} If strict is set, but the return instance did not reutrn a valid instance.\r\n   *\r\n   * @param  {*} type\r\n   * @param  {Boolean=} strict\r\n   * @return {*}\r\n   */\r\n  var instance = function (type, strict) {\r\n    var descriptor = map.get(type),\r\n        instance = null;\r\n\r\n    if (descriptor == null) {\r\n      throw new Error('Dependency ' + typeToString(type) + ' could not be resolved because it has not been registered.');\r\n    }\r\n\r\n    var id = descriptor.id,\r\n        lifecycle = descriptor.lifecycle;\r\n\r\n    if (descriptor.pending === true) {\r\n      throw new Error('Circular dependency detected while resolving ' + typeToString(type, id) + '.');\r\n    }\r\n\r\n    descriptor.pending = true;\r\n\r\n    try {\r\n      switch (lifecycle) {\r\n        case Lifecycle.SINGLETON:\r\n          instance = asSingleton(descriptor);\r\n          break;\r\n        case Lifecycle.TRANSIENT:\r\n          instance = asTransient(descriptor);\r\n          break;\r\n        default:\r\n          throw new Error('Unsupported lifecycle ' + lifecycle + '.');\r\n      }\r\n    } finally {\r\n      descriptor.pending = false;\r\n    }\r\n\r\n    if (instance == null && strict) {\r\n      throw new Error(typeToString(type, id) + ' failed to return a value in strict mode.');\r\n    }\r\n\r\n    return instance;\r\n  };\r\n\r\n  /**\r\n   * Returns a singleton instance.\r\n   *\r\n   * @param  {Object} descriptor\r\n   * @return {*}\r\n   */\r\n  var asSingleton = function (descriptor) {\r\n    var id = descriptor.id;\r\n\r\n    if (cache[id] == null) {\r\n      cache[id] = asTransient(descriptor);\r\n    }\r\n\r\n    return cache[id];\r\n  };\r\n\r\n  /**\r\n   * Creates a new instance.\r\n   *\r\n   * @param  {Object} descriptor\r\n   * @return {*}\r\n   */\r\n  var asTransient = function (descriptor) {\r\n    return descriptor.factory(api);\r\n  };\r\n\r\n  /**\r\n   * Creates a formated string from a type and id.\r\n   *\r\n   * @param  {*} type\r\n   * @param  {String=} uid\r\n   * @return {String}\r\n   */\r\n  var typeToString = function (type, uid) {\r\n    var result = type;\r\n\r\n    if (uid != null) {\r\n      result += '(' + uid + ')';\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  var api = {\r\n    bind: bind,\r\n    factory: factory,\r\n    instance: instance\r\n  };\r\n\r\n  return api;\r\n};\r\n","/**\r\n * Creates a container compatible factory from a constructor of type T.\r\n *\r\n * @param  {Function} constructor\r\n * @param  {Array} dependencies\r\n * @return {Function}\r\n */\r\nvar asFactory = function (constructor, dependencies) {\r\n  return function (container) {\r\n    return construct(constructor, dependencies.map(function (dependency) {\r\n      return container.instance(dependency);\r\n    }));\r\n  };\r\n};\r\n\r\n/**\r\n * Creates a new object from its constructor.\r\n *\r\n * @param  {Function} constructor\r\n * @param  {Array=} params\r\n * @return {Object}\r\n */\r\nvar construct = function (constructor, params) {\r\n  return new (Function.bind.apply(constructor, [null].concat(params)))();\r\n};\r\n\r\n/**\r\n * Create a unique id for a dependency;\r\n *\r\n * @return {String}\r\n */\r\nvar uid = (function () {\r\n  var uid = 0;\r\n\r\n  var next = function () {\r\n    return ':' + uid++;\r\n  };\r\n\r\n  return next;\r\n})();\r\n\r\n/**\r\n * Slice array shortcut.\r\n *\r\n * @type {Function}\r\n */\r\nvar slice = Array.prototype.slice;\r\n\r\n/**\r\n * Has own property shortcut.\r\n *\r\n * @type {Function}\r\n */\r\nvar has = Object.prototype.hasOwnProperty;\r\n","/**\r\n * Brandy factory.\r\n *\r\n * @return {Container}\r\n */\r\nvar brandy = function () {\r\n  return new Container(new Mapping());\r\n};\r\n\r\n/**\r\n * Brandy build version.\r\n *\r\n * @type {String}\r\n */\r\nbrandy.version = '<%= version %>';\r\n\r\n(function (root, factory) {\r\n  if (typeof define === 'function' && define.amd) {\r\n    define(function () {\r\n      return factory;\r\n    });\r\n  } else if (typeof exports === 'object' && module.exports) {\r\n    module.exports = factory;\r\n  } else {\r\n    global.Brandy = factory;\r\n  }\r\n})(global, brandy);\r\n","/**\r\n * Describes possible object lifecycles.\r\n *\r\n * @enum {String}\r\n */\r\nvar Lifecycle = {\r\n\r\n  /**\r\n   * Transient objects are created new every time its requested.\r\n   *\r\n   * @type {String}\r\n   */\r\n  TRANSIENT: 'TRANSIENT',\r\n\r\n  /**\r\n   * Singleton objects are only ever created once then cached.\r\n   *\r\n   * @type {String}\r\n   */\r\n  SINGLETON: 'SINGLETON',\r\n\r\n  /**\r\n   * Default lifecycle.\r\n   *\r\n   * @type {String}\r\n   */\r\n  DEFAULT: 'SINGLETON',\r\n\r\n  /**\r\n   * Parses a value to a valid enum type.\r\n   *\r\n   * @throws {Error} If unable to parse.\r\n   *\r\n   * @param  {String} value\r\n   * @return {String}\r\n   */\r\n  parse: function (value) {\r\n    if (typeof value == 'string') {\r\n      var name = value.toUpperCase();\r\n\r\n      if (has.call(Lifecycle, name) && typeof Lifecycle[name] === 'string') {\r\n        return Lifecycle[name];\r\n      }\r\n    }\r\n\r\n    throw new Error('Unable to parse ' + value + ' as Lifecycle.');\r\n  }\r\n};\r\n","/**\r\n * Map like constructor. Mapping will attempt to delegate to native map if\r\n * supported.\r\n */\r\nvar Mapping = (function (root) {\r\n\r\n  /**\r\n   * Can we use native maps?\r\n   *\r\n   * @type {Boolean}\r\n   */\r\n  var NATIVE_MAP_SUPPORTED = 'Map' in global;\r\n\r\n  /**\r\n   * A thin and very incomplete map implementation for environments that\r\n   * dont support native maps.\r\n   */\r\n  var Mapping = function () {\r\n    var keys = [],\r\n        values = [];\r\n\r\n    /**\r\n     * Gets a value by key.\r\n     *\r\n     * @param  {*} key\r\n     * @return {*}\r\n     */\r\n    var get = function (key) {\r\n      return values[keys.indexOf(key)];\r\n    };\r\n\r\n    /**\r\n     * Sets a value by key.\r\n     *\r\n     * @param {*} key\r\n     * @param {*} value\r\n     * @return {Mapping}\r\n     */\r\n    var set = function (key, value) {\r\n      var index = keys.indexOf(key);\r\n\r\n      if (index === -1) {\r\n        keys.push(key);\r\n        values.push(value);\r\n      } else {\r\n        keys[index] = key;\r\n        values[index] = value;\r\n      }\r\n\r\n      return api;\r\n    };\r\n\r\n    /**\r\n     * Public api.\r\n     *\r\n     * @type {Object}\r\n     */\r\n    var api = {\r\n      get: get,\r\n      set: set\r\n    };\r\n\r\n    return api;\r\n  };\r\n\r\n  return NATIVE_MAP_SUPPORTED\r\n    ? global.Map\r\n    : Mapping;\r\n})(global);\r\n"],"sourceRoot":"/source/"}